<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ASCII Photon — v0.5.5.3 Hotfix (Can’t Miss Me)</title>
<style>
  html, body { margin:0; padding:0; background:#000; color:#cfe9ff; height:100%; }
  #wrap { display:flex; flex-direction:column; height:100%; }
  #ui { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        font-size:14px; line-height:1.35; padding:8px 10px; color:#bfe3ff; background:#0b1016; border-bottom:1px solid #0f1926; }
  #ui code { color:#ffe08a; }
  #c { flex: 1 1 auto; display:block; width:100%; height:100%; background:#000; }
</style>
</head>
<body>
<div id="wrap">
  <div id="ui">
    <strong>ASCII Photon — v0.5.5.3 Hotfix (Can’t Miss Me)</strong> — Aim WASD, move arrows, Space tap/hold, T toggle, 1..5 presets, -/= fine, G drain, R reset, C center, F flash, H aim.
  </div>
  <canvas id="c"></canvas>
</div>

<script>
(function main(){
  // ---- Debug: show any JS error right on the canvas ----
  const errorMessages = [];
  window.addEventListener('error', e => {
    errorMessages.push(String(e.message || e.error || 'Unknown error'));
  });
  const cellW = 9, cellH = 16;
  let cols = 128, rows = 48;
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true });
  ctx.imageSmoothingEnabled = false;
  ctx.textBaseline = 'top';
  ctx.font = '14px Courier New, monospace';

  const Laser = {
    x: Math.floor(cols*0.5),
    y: Math.floor(rows*0.55),
    angle: 0,
    lambdaNm: 600,
    fireHeld: false,
    fireLatched: false,
    drainOn: true,
    fireRate: 12,
    fireCooldown: 0,
    batteryMax: 100,
    battery: 100,
    rechargePerSec: 8,
    speedScale(nm){
      const LMIN=200, LMAX=800;
      const inv = 1/Math.min(Math.max(nm,LMIN), LMAX);
      const invMin=1/LMIN, invMax=1/LMAX;
      return 1.0 + 0.7 * ((inv - invMax) / (invMin - invMax));
    },
    costPerShot(nm){
      const inv = 1/Math.min(Math.max(nm, 200), 800);
      const invMin = 1/800, invMax = 1/200;
      const t = (inv - invMin) / (invMax - invMin);
      const cmin = 0.18, cmax = 0.95;
      return cmin + (cmax - cmin) * Math.min(Math.max(t,0),1);
    }
  };
  function clampEmitter(){
    Laser.x = Math.max(1, Math.min(cols-2, Laser.x));
    Laser.y = Math.max(1, Math.min(rows-2, Laser.y));
  }
  function fitCanvas(){
    const W = window.innerWidth;
    const H = window.innerHeight - document.getElementById('ui').offsetHeight;
    cols = Math.max(96, Math.floor(W / cellW));
    rows = Math.max(32, Math.floor(H / cellH));
    canvas.width = cols * cellW;
    canvas.height = rows * cellH;
    clampEmitter();
    placeAtoms();
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();
  // Force center once more just in case
  Laser.x = Math.floor(cols*0.5);
  Laser.y = Math.floor(rows*0.55);

  // Atoms
  const atoms=[];
  function placeAtoms(){
    atoms.length = 0;
    const spots = [
      { fx:0.60, fy:0.30, name:'Na',  nm: 589, tol:8 },
      { fx:0.78, fy:0.55, name:'Cl₂', nm: 520, tol:10 },
      { fx:0.46, fy:0.72, name:'Hg',  nm: 436, tol:6 },
      { fx:0.70, fy:0.25, name:'O₂',  nm: 760, tol:12 }
    ];
    for (const s of spots){
      atoms.push({ x: Math.floor(cols*s.fx), y: Math.floor(rows*s.fy),
                   label: s.name, resNm: s.nm, tol: s.tol, excited: 0 });
    }
  }

  // Input
  const keys = new Set();
  window.addEventListener('keydown', (e)=>{
    keys.add(e.key);
    if (e.key === ' ') { fireSingle(); Laser.fireHeld = true; e.preventDefault(); }
    if (e.key === 't' || e.key === 'T') Laser.fireLatched = !Laser.fireLatched;
    if (e.key === 'g' || e.key === 'G') Laser.drainOn = !Laser.drainOn;
    if (e.key === '1') Laser.lambdaNm = 700;
    if (e.key === '2') Laser.lambdaNm = 600;
    if (e.key === '3') Laser.lambdaNm = 500;
    if (e.key === '4') Laser.lambdaNm = 400;
    if (e.key === '5') Laser.lambdaNm = 320;
    if (e.key === '-' || e.key === '_') Laser.lambdaNm = Math.min(800, Math.max(200, Laser.lambdaNm + 5));
    if (e.key === '=' || e.key === '+') Laser.lambdaNm = Math.min(800, Math.max(200, Laser.lambdaNm - 5));
    if (e.key === 'r' || e.key === 'R') resetWorld();
    if (e.key === 'c' || e.key === 'C') centerMe();
    if (e.key === 'f' || e.key === 'F') findMeTimer = 1.1;
    if (e.key === 'h' || e.key === 'H') showAimPreview = !showAimPreview;
    if (e.key === 'b' || e.key === 'B') Laser.battery = Laser.batteryMax;
  });
  window.addEventListener('keyup', (e)=>{
    keys.delete(e.key);
    if (e.key === ' ') Laser.fireHeld = false;
  });
  function resetWorld(){
    Laser.x = Math.floor(cols*0.5);
    Laser.y = Math.floor(rows*0.55);
    Laser.angle = 0;
    Laser.battery = Laser.batteryMax;
    photons.length = 0;
    emissions.length = 0;
    for (const a of atoms) a.excited = 0;
  }
  function centerMe(){ Laser.x = Math.floor(cols*0.5); Laser.y = Math.floor(rows*0.5); }

  // Aim & move
  function aimFromWASD(){
    let ax=0, ay=0;
    if (keys.has('w') || keys.has('W')) ay -= 1;
    if (keys.has('s') || keys.has('S')) ay += 1;
    if (keys.has('a') || keys.has('A')) ax -= 1;
    if (keys.has('d') || keys.has('D')) ax += 1;
    if (ax===0 && ay===0) return;
    Laser.angle = Math.atan2(ay, ax);
  }
  function moveWithArrows(dt){
    const mv=18*dt;
    if (keys.has('ArrowUp')) Laser.y -= mv;
    if (keys.has('ArrowDown')) Laser.y += mv;
    if (keys.has('ArrowLeft')) Laser.x -= mv;
    if (keys.has('ArrowRight')) Laser.x += mv;
    clampEmitter();
  }

  // Physics helpers
  function segmentDistance(ax,ay,bx,by,cx,cy){
    const dx=bx-ax, dy=by-ay;
    const len2=dx*dx + dy*dy + 1e-6;
    const t=Math.max(0, Math.min(1, ((cx-ax)*dx + (cy-ay)*dy) / len2));
    const px=ax + t*dx, py=ay + t*dy;
    return Math.hypot(px-cx, py-cy);
  }
  function wavelengthToColor(nm){
    const x = Math.min(1, Math.max(0, (nm - 380) / (700 - 380)));
    const hue = (1 - x) * 270;
    const s = 0.65, v = 1.0;
    const c = v * s;
    const h = hue / 60;
    const xcol = c * (1 - Math.abs((h % 2) - 1));
    let r=0,g=0,b=0;
    if (0<=h && h<1){ r=c; g=xcol; b=0; }
    else if (1<=h && h<2){ r=xcol; g=c; b=0; }
    else if (2<=h && h<3){ r=0; g=c; b=xcol; }
    else if (3<=h && h<4){ r=0; g=xcol; b=c; }
    else if (4<=h && h<5){ r=xcol; g=0; b=c; }
    else { r=c; g=0; b=xcol; }
    const m = v - c;
    return { r:Math.round((r+m)*255), g:Math.round((g+m)*255), b:Math.round((b+m)*255) };
  }

  // Photons
  const MAX_PHOTONS = 80;
  class Photon {
    constructor(x,y,angle,lambdaNm){
      this.x=x; this.y=y; this.px=x; this.py=y;
      const v = 36;
      this.vx=Math.cos(angle)*v; this.vy=Math.sin(angle)*v;
      this.lambdaNm=lambdaNm; this.age=0; this.life=4.0;
    }
    step(dt){ this.px=this.x; this.py=this.y; this.x += this.vx*dt; this.y += this.vy*dt; this.age += dt; }
    alive(){ return this.age<=this.life && this.x>=0 && this.x<cols && this.y>=0 && this.y<rows; }
  }
  const photons=[];
  function fireSingle(){
    if (Laser.drainOn && Laser.battery <= 0) return;
    const p = new Photon(Laser.x, Laser.y, Laser.angle, Laser.lambdaNm);
    photons.push(p); while (photons.length > MAX_PHOTONS) photons.shift();
    if (Laser.drainOn) Laser.battery = Math.max(0, Laser.battery - Laser.costPerShot(Laser.lambdaNm));
  }

  // Emissions
  class Emission {
    constructor(x,y,lambdaNm,ampScale=1){
      this.x=x; this.y=y; this.lambdaNm=lambdaNm; this.t=0;
      this.life=1.2; this.waveSpeed = 14.0 * Laser.speedScale(lambdaNm);
      this.ringSigma = 0.75; this.coreSigma = 0.5; this.glowReach = 10.0; this.glowStrength = 0.35;
      this.ampScale = ampScale;
    }
    step(dt){ this.t += dt; } alive(){ return this.t < this.life; }
    bboxContainsCell(cx,cy){ const r = Math.max(3.0, (this.waveSpeed*this.t) + 3.5); return Math.abs(cx - this.x) <= r && Math.abs(cy - this.y) <= r; }
    sample(cx,cy){
      const dx=cx - this.x, dy=cy - this.y, d=Math.hypot(dx,dy), w = this.waveSpeed * this.t;
      const ring = Math.exp(-((d - w)*(d - w)) / (2*this.ringSigma*this.ringSigma));
      const core = Math.exp(-(d*d)/(2*this.coreSigma*this.coreSigma));
      const glow = this.glowStrength * Math.exp(-d / this.glowReach);
      const env = Math.max(0, 1 - (this.t/this.life));
      const shimmer = 0.75 + 0.25 * Math.sin(this.t * 7.0 + d*2.0);
      return Math.min(1.0, (0.7*ring + 0.6*core + glow) * env * shimmer) * this.ampScale;
    }
  }
  const emissions=[];
  function tryExcite(p){
    const hitRadius = 0.8;
    for (const a of atoms){
      const d = segmentDistance(p.px,p.py,p.x,p.y, a.x+0.5, a.y+0.5);
      if (d <= hitRadius){
        const delta = Math.abs(Laser.lambdaNm - a.resNm);
        const eff = Math.exp(- (delta*delta) / (2 * a.tol * a.tol));
        const amp = 0.35 + 0.65*eff;
        emissions.push(new Emission(a.x+0.5, a.y+0.5, Laser.lambdaNm, amp));
        a.excited = 0.8 * (0.6 + 0.4*eff);
        return true;
      }
    }
    // wall scatter
    if (p.x<1 || p.x>cols-2 || p.y<1 || p.y>rows-2){
      const wx = Math.min(Math.max(p.x,1), cols-2);
      const wy = Math.min(Math.max(p.y,1), rows-2);
      emissions.push(new Emission(wx, wy, Laser.lambdaNm, 0.25));
      return true;
    }
    return false;
  }

  // Aim preview
  let showAimPreview = true;
  let findMeTimer = 0;
  function rayPoints(x, y, angle, maxLen){
    const pts=[]; const dx=Math.cos(angle), dy=Math.sin(angle);
    for (let i=0;i<maxLen;i++){ const nx=Math.round(x+dx*i), ny=Math.round(y+dy*i);
      if (nx<1 || nx>=cols-1 || ny<1 || ny>=rows-1) break;
      if (!pts.length || pts[pts.length-1].x!==nx || pts[pts.length-1].y!==ny) pts.push({x:nx,y:ny});
    } return pts;
  }

  const ramp=" .:-=+*#@%"; const rampLen=ramp.length;
  function drawEmitterMarker(){
    const ex = Math.round(Laser.x), ey = Math.round(Laser.y);
    // Giant target reticle
    ctx.fillStyle='rgba(255,255,255,0.95)';
    ctx.fillText('@', ex*cellW, ey*cellH);
    const arms = [[-1,0],[1,0],[0,-1],[0,1],[-2,0],[2,0],[0,-2],[0,2]];
    for (const [dx,dy] of arms){
      const gx=ex+dx, gy=ey+dy;
      if (gx>=0&&gx<cols&&gy>=0&&gy<rows) ctx.fillText('+', gx*cellW, gy*cellH);
    }
    ctx.fillText('YOU', Math.max(0,ex-1)*cellW, Math.max(0,ey-2)*cellH);
  }

  let prev=performance.now();
  function frame(now){
    const dt=Math.min(0.033,(now-prev)/1000); prev=now;
    aimFromWASD(); moveWithArrows(dt);

    // Shooting
    const firing = (Laser.fireHeld || Laser.fireLatched) && (Laser.drainOn ? Laser.battery>0 : true);
    Laser.fireCooldown -= dt;
    if (firing && Laser.fireCooldown <= 0){ fireSingle(); Laser.fireCooldown = 1 / Laser.fireRate; }
    if (!firing && Laser.drainOn){ Laser.battery = Math.min(Laser.batteryMax, Laser.battery + Laser.rechargePerSec * dt); }

    // Step
    for (let i=photons.length-1;i>=0;i--){
      const p=photons[i]; p.step(dt); const hit = tryExcite(p);
      if (hit || !p.alive()) photons.splice(i,1);
    }
    for (let i=emissions.length-1;i>=0;i--){ const e=emissions[i]; e.step(dt); if (!e.alive()) emissions.splice(i,1); }
    for (const a of atoms){ if (a.excited>0) a.excited -= dt; if (a.excited<0) a.excited=0; }

    // Draw
    ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
    const tint=wavelengthToColor(Laser.lambdaNm); const rgba=(a=1)=>`rgba(${tint.r},${tint.g},${tint.b},${a})`;

    // Emissions field
    for (let y=0;y<rows;y++){
      for (let x=0;x<cols;x++){
        let amp=0; const cx=x+0.5, cy=y+0.5;
        for (const e of emissions){ if (e.bboxContainsCell(cx,cy)) amp = Math.max(amp, e.sample(cx,cy)); }
        if (amp>0.06){ const idx=Math.min(rampLen-1, Math.max(0, Math.floor(amp*(rampLen-1))));
          ctx.fillStyle=rgba(Math.min(1, 0.18 + amp*0.95)); ctx.fillText(ramp[idx], x*cellW, y*cellH); }
      }
    }

    // Atoms
    for (const a of atoms){
      const color = a.excited>0 ? `rgba(120,255,150,0.95)` : `rgba(150,200,255,0.85)`;
      ctx.fillStyle=color; ctx.fillText('O', a.x*cellW, a.y*cellH);
      ctx.fillStyle='rgba(150,200,255,0.6)'; ctx.fillText(`${a.label}[${a.resNm}nm]`, Math.max(0,(a.x-2))*cellW, Math.max(0,(a.y-1))*cellH);
    }

    // Aim preview
    if (showAimPreview){ const pts = rayPoints(Laser.x, Laser.y, Laser.angle, Math.floor(cols*0.8));
      ctx.fillStyle='rgba(255,255,255,0.28)'; for (let i=0;i<pts.length;i+=2){ const p=pts[i]; ctx.fillText('.', p.x*cellW, p.y*cellH); } }

    // Emitter marker + photons
    drawEmitterMarker();
    for (const p of photons){ ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillText('*', Math.round(p.x)*cellW, Math.round(p.y)*cellH); }

    // Debug errors overlay
    if (errorMessages.length){
      ctx.fillStyle='rgba(255,80,80,0.95)'; ctx.fillText('ERROR:', 2*cellW, 2*cellH);
      errorMessages.slice(-3).forEach((m,i)=>{ ctx.fillText(String(m).slice(0,80), 2*cellW, (3+i)*cellH); });
    }

    // HUD
    function text(x,y,s,style){ ctx.fillStyle=style; ctx.fillText(s, x*cellW, y*cellH); }
    const s=Laser.speedScale(Laser.lambdaNm).toFixed(2), nm=Math.round(Laser.lambdaNm);
    const mode = (Laser.fireHeld || Laser.fireLatched) ? "FIRE: ON" : "FIRE: OFF";
    const bar = Math.floor((Laser.battery/Laser.batteryMax)*20);
    text(1,1,`λ=${nm} nm  speed×${s}  ${mode}  aim: WASD  move: arrows`, 'rgba(180,220,255,0.9)');
    text(1,2,`battery [${'#'.repeat(bar)}${'.'.repeat(20-bar)}] ${Math.max(0,Math.round(Laser.battery))}/${Laser.batteryMax}  photons:${photons.length}  emit:${emissions.length}`, 'rgba(160,200,255,0.85)');

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
