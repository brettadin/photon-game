<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ASCII Photon — v0.7.0.1 Hotfix (Find‑Me Again)</title>
<style>
  html, body { margin:0; padding:0; background:#000; color:#cfe9ff; height:100%; }
  #wrap { display:flex; flex-direction:column; height:100%; }
  #ui { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        font-size:14px; line-height:1.35; padding:8px 10px; color:#bfe3ff; background:#0b1016; border-bottom:1px solid #0f1926; }
  #ui code { color:#ffe08a; }
  #c { flex: 1 1 auto; display:block; width:100%; height:100%; background:#000; }
</style>
</head>
<body>
<div id="wrap">
  <div id="ui">
    <strong>ASCII Photon — v0.7.0.1 Hotfix (Find‑Me Again)</strong>
    — Move <b>WASD</b>, aim mouse, fire <b>Space/Click</b>. <code>C</code> center, <code>V</code> beacon toggle, <code>F</code> flash, <code>H</code> aim dots, <code>D</code> debug.
    If anything fails, an error shows on canvas.
  </div>
  <canvas id="c"></canvas>
</div>

<script>
(() => {
  // ==== Global error to canvas ====
  const errs=[];
  window.onerror = (msg, src, line, col, err) => { errs.push(String(msg||err||'error')); return false; };

  const cellW=12, cellH=20; let cols=100, rows=44;
  const canvas=document.getElementById('c'); const ctx=canvas.getContext('2d');
  ctx.imageSmoothingEnabled=false; ctx.textBaseline='top'; ctx.font='18px Courier New, monospace';

  function fit(){ const H=window.innerHeight - document.getElementById('ui').offsetHeight, W=window.innerWidth;
    cols=Math.max(60, Math.floor(W/cellW)); rows=Math.max(30, Math.floor(H/cellH));
    canvas.width=cols*cellW; canvas.height=rows*cellH; }
  window.addEventListener('resize', ()=>{ fit(); centerMe(); }); fit();

  // ==== Player / state ====
  const Game={ state:'playing', bonds:0, target:6, level:0, time:0 };
  const P={ x:Math.floor(cols*0.5), y:Math.floor(rows*0.6), ang:0, λ:600, move:22,
            fireHeld:false, latched:false, rate:12, cd:0, drain:true, batMax:100, bat:100, rech:8 };
  function centerMe(){ P.x=Math.floor(cols*0.5); P.y=Math.floor(rows*0.6); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function w2rgb(nm){ const n=Math.max(200,Math.min(800,nm)), x=Math.min(1,Math.max(0,(n-380)/(700-380)));
    const hue=(1-x)*270, s=.65,v=1,c=v*s,h=hue/60, xcol=c*(1-Math.abs((h%2)-1)); let r=0,g=0,b=0;
    if(0<=h&&h<1){r=c;g=xcol;} else if(1<=h&&h<2){r=xcol;g=c;} else if(2<=h&&h<3){g=c;b=xcol;}
    else if(3<=h&&h<4){g=xcol;b=c;} else if(4<=h&&h<5){r=xcol;b=c;} else {r=c;b=xcol;}
    const m=v-c; return {r:Math.round((r+m)*255),g:Math.round((g+m)*255),b:Math.round((b+m)*255)}; }
  const ramp=" .:-=+*#@%", rampLen=ramp.length;

  // ==== Input ====
  const K=new Set();
  window.addEventListener('keydown',e=>{
    K.add(e.key);
    if(e.key===' '){ fireSingle(); P.fireHeld=true; e.preventDefault(); }
    if(e.key==='t'||e.key==='T') P.latched=!P.latched;
    if(e.key==='g'||e.key==='G') P.drain=!P.drain;
    if(e.key==='1') P.λ=700; if(e.key==='2') P.λ=600; if(e.key==='3') P.λ=500; if(e.key==='4') P.λ=400; if(e.key==='5') P.λ=320;
    if(e.key==='-'||e.key==='_') P.λ=Math.min(800, Math.max(200, P.λ+5));
    if(e.key==='='||e.key==='+') P.λ=Math.min(800, Math.max(200, P.λ-5));
    if(e.key==='c'||e.key==='C') centerMe();
    if(e.key==='f'||e.key==='F') ping=1.0;
    if(e.key==='d'||e.key==='D') debug=!debug;
    if(e.key==='h'||e.key==='H') aimDots=!aimDots;
    if(e.key==='v'||e.key==='V') beacon=!beacon;
  });
  window.addEventListener('keyup',e=>{ K.delete(e.key); if(e.key===' ') P.fireHeld=false; });

  let mouse={x:0,y:0};
  canvas.addEventListener('mousemove',e=>{
    const r=canvas.getBoundingClientRect();
    mouse.x=Math.floor((e.clientX-r.left)/cellW); mouse.y=Math.floor((e.clientY-r.top)/cellH);
    const ax=mouse.x-P.x, ay=mouse.y-P.y; if(ax||ay) P.ang=Math.atan2(ay,ax);
  });
  canvas.addEventListener('mousedown',()=>{ fireToward(mouse.x,mouse.y); P.fireHeld=true; });
  window.addEventListener('mouseup',()=>{ P.fireHeld=false; });
  canvas.addEventListener('click',()=>{ fireToward(mouse.x,mouse.y); });

  function move(dt){
    let mx=0,my=0;
    if (K.has('w')||K.has('W')) my-=1;
    if (K.has('s')||K.has('S')) my+=1;
    if (K.has('a')||K.has('A')) mx-=1;
    if (K.has('d')||K.has('D')) mx+=1;
    if (mx||my){ const n=Math.hypot(mx,my)||1; P.x=clamp(P.x+(mx/n)*P.move*dt,1,cols-2); P.y=clamp(P.y+(my/n)*P.move*dt,1,rows-2); }
  }

  function cost(nm){ const inv=1/Math.max(200,Math.min(800,nm)); const t=(inv-(1/800))/((1/200)-(1/800)); return 0.18+0.95*Math.max(0,Math.min(1,t)); }

  // ==== Entities ====
  class Photon{ constructor(x,y,a,nm){ this.x=x;this.y=y;this.px=x;this.py=y; const v=36; this.vx=Math.cos(a)*v; this.vy=Math.sin(a)*v; this.nm=nm; this.age=0; this.life=4;}
    step(dt){ this.px=this.x; this.py=this.y; this.x+=this.vx*dt; this.y+=this.vy*dt; this.age+=dt; }
    alive(){ return this.age<=this.life && this.x>=0&&this.x<cols&&this.y>=0&&this.y<rows; } }
  const photons=[]; const MAXP=120;
  function fireSingle(){ if(P.drain && P.bat<=0) return; photons.push(new Photon(P.x,P.y,P.ang,P.λ)); while(photons.length>MAXP) photons.shift(); if(P.drain) P.bat=Math.max(0,P.bat-cost(P.λ)); }
  function fireToward(cx,cy){ const ang=Math.atan2(cy-P.y,cx-P.x); photons.push(new Photon(P.x,P.y,ang,P.λ)); while(photons.length>MAXP) photons.shift(); if(P.drain) P.bat=Math.max(0,P.bat-cost(P.λ)); }

  function nmFromEV(E){ return 1240/Math.max(0.1,E); }
  class Emission{ constructor(x,y,nm,amp=1){ this.x=x; this.y=y; this.nm=nm; this.t=0; this.life=1.25;
      const L=Math.max(200,Math.min(800,nm)); const inv=1/L, invMin=1/800, invMax=1/200; const k=1.0+0.7*((inv-invMax)/(invMin-invMax));
      this.wave=14*k; this.ringS=0.75; this.coreS=0.5; this.glowR=10; this.glowK=0.35; this.amp=amp; }
    step(dt){ this.t+=dt; } alive(){ return this.t<this.life; }
    bb(cx,cy){ const r=Math.max(3,this.wave*this.t+4); return Math.abs(cx-this.x)<=r && Math.abs(cy-this.y)<=r; }
    sample(cx,cy){ const dx=cx-this.x,dy=cy-this.y,d=Math.hypot(dx,dy), w=this.wave*this.t;
      const ring=Math.exp(-((d-w)*(d-w))/(2*this.ringS*this.ringS));
      const core=Math.exp(-(d*d)/(2*this.coreS*this.coreS));
      const glow=this.glowK*Math.exp(-d/this.glowR);
      const env=Math.max(0,1-(this.t/this.life)); const shim=0.75+0.25*Math.sin(this.t*7+d*2);
      return Math.min(1,(0.7*ring+0.6*core+glow)*env*shim)*this.amp; } }
  const emits=[];

  const MOLECS=[
    { label:'A₂', Eb:3.0, len:5, sp:6 },
    { label:'H₂', Eb:4.5, len:5, sp:7 },
    { label:'O₂', Eb:5.1, len:6, sp:5.5 },
    { label:'CO', Eb:3.6, len:6, sp:6.5 },
  ];
  class Mol{ constructor(k,x,y,vx,vy){ this.k=k; this.cx=x; this.cy=y; this.vx=vx; this.vy=vy;
      this.a=Math.random()*Math.PI*2; this.av=(Math.random()-0.5)*0.6; this.len=k.len; this.emit=nmFromEV(k.Eb); }
    ends(){ const dx=Math.cos(this.a), dy=Math.sin(this.a); return {ax:this.cx-dx*this.len*.5, ay:this.cy-dy*this.len*.5, bx:this.cx+dx*this.len*.5, by:this.cy+dy*this.len*.5}; }
    step(dt){ this.cx+=this.vx*dt; this.cy+=this.vy*dt; this.a+=this.av*dt; if(this.cx<2||this.cx>cols-3){this.vx*=-1; this.cx=clamp(this.cx,2,cols-3);} if(this.cy<2||this.cy>rows-3){this.vy*=-1; this.cy=clamp(this.cy,2,rows-3);} }
    draw(){ const e=this.ends(), dx=e.bx-e.ax, dy=e.by-e.ay, steps=Math.max(2,Math.ceil(Math.hypot(dx,dy))); const c=w2rgb(this.emit);
      ctx.fillStyle=`rgba(${c.r},${c.g},${c.b},0.4)`; for(let i=0;i<=steps;i++){ const x=Math.round(e.ax+dx*(i/steps)), y=Math.round(e.ay+dy*(i/steps)); if(x>=0&&x<cols&&y>=0&&y<rows) ctx.fillText('-', x*cellW, y*cellH); }
      ctx.fillStyle='rgba(150,200,255,0.95)'; ctx.fillText('o', Math.round(e.ax)*cellW, Math.round(e.ay)*cellH); ctx.fillText('o', Math.round(e.bx)*cellW, Math.round(e.by)*cellH);
      ctx.fillStyle='rgba(150,200,255,0.65)'; ctx.fillText(`${this.k.label}[${this.k.Eb.toFixed(1)}eV→${Math.round(this.emit)}nm]`, Math.round(this.cx-3)*cellW, Math.round(this.cy-2)*cellH); } }
  const mols=[];
  function spawn(n=7){ mols.length=0; for(let i=0;i<n;i++){ const k=MOLECS[Math.floor(Math.random()*MOLECS.length)];
      const x=5+Math.random()*(cols-10), y=4+Math.random()*(rows-8), ang=Math.random()*Math.PI*2, sp=k.sp*(0.7+0.6*Math.random());
      mols.push(new Mol(k,x,y, Math.cos(ang)*sp, Math.sin(ang)*sp)); } }
  spawn(8);

  // ==== Collisions ====
  function segDist(ax,ay,bx,by,cx,cy){ const dx=bx-ax,dy=by-ay,len2=dx*dx+dy*dy+1e-6; const t=Math.max(0,Math.min(1,((cx-ax)*dx+(cy-ay)*dy)/len2)); const px=ax+t*dx,py=ay+t*dy; return Math.hypot(px-cx,py-cy); }
  function tryBreak(p){
    for(let i=0;i<mols.length;i++){ const m=mols[i], e=m.ends(), d=segDist(p.px,p.py,p.x,p.y,(e.ax+e.bx)/2,(e.ay+e.by)/2);
      if(d<=1.0){ const Eph=1240/p.nm;
        if(Eph>=m.k.Eb){ const nx=(e.ax+e.bx)/2, ny=(e.ay+e.by)/2; emits.push(new Emission(nx,ny,m.emit,1.0)); emits.push(new Emission(e.ax,e.ay,p.nm,0.35)); emits.push(new Emission(e.bx,e.by,p.nm,0.35)); mols.splice(i,1); Game.bonds++; }
        else { const hx=(e.ax+e.bx)/2, hy=(e.ay+e.by)/2; emits.push(new Emission(hx,hy,p.nm,0.25)); }
        return true; } }
    if(p.x<1||p.x>cols-2||p.y<1||p.y>rows-2){ emits.push(new Emission(clamp(p.x,1,cols-2), clamp(p.y,1,rows-2), p.nm, 0.25)); return true; }
    return false; }

  // ==== Visibility beacons ====
  let ping=0, beacon=true, debug=false, aimDots=true, bootChecked=false, bootOK=true, dtGlobal=0;
  function drawPlayer(){
    const ex=Math.round(P.x), ey=Math.round(P.y);
    // fat block cross (always)
    ctx.fillStyle='rgba(255,255,255,0.96)';
    ctx.fillRect(ex*cellW, ey*cellH, cellW, cellH);
    ctx.fillRect((ex-1)*cellW, ey*cellH, cellW, cellH);
    ctx.fillRect((ex+1)*cellW, ey*cellH, cellW, cellH);
    ctx.fillRect(ex*cellW, (ey-1)*cellH, cellW, cellH);
    ctx.fillRect(ex*cellW, (ey+1)*cellH, cellW, cellH);
    // text
    ctx.fillStyle='rgba(0,0,0,0.9)'; ctx.fillText('@', ex*cellW, ey*cellH);
    ctx.fillStyle='rgba(255,255,255,0.98)'; ctx.fillText('YOU', Math.max(0,ex-1)*cellW, Math.max(0,ey-2)*cellH);

    // rotating arrow beacon
    if (beacon){
      const r=6, ang=Date.now()*0.004, tipx=Math.round(ex+Math.cos(ang)*r), tipy=Math.round(ey+Math.sin(ang)*r);
      ctx.fillStyle='rgba(255,255,0,0.95)'; ctx.fillText('^', tipx*cellW, tipy*cellH);
      // small spokes
      for(let a=0;a<Math.PI*2;a+=Math.PI/3){ const px=Math.round(ex+Math.cos(a)*(r-2)), py=Math.round(ey+Math.sin(a)*(r-2));
        ctx.fillText('*', px*cellW, py*cellH); }
    }
    // ping
    if (ping>0){ ping-=dtGlobal; const phase=1-Math.max(0,ping/1.0), rad=4+phase*12; ctx.fillStyle='rgba(255,255,255,0.9)';
      for(let a=0;a<Math.PI*2;a+=0.28){ const px=Math.round(ex+Math.cos(a)*rad), py=Math.round(ey+Math.sin(a)*rad); if(px>=0&&px<cols&&py>=0&&py<rows) ctx.fillText('o', px*cellW, py*cellH); } }
  }

  // ==== Boot self-test: verify canvas writes ====
  function bootTest(){ const cx=Math.floor(canvas.width/2), cy=Math.floor(canvas.height/2); ctx.fillStyle='#fff'; ctx.fillRect(cx-2,cy-2,4,4);
    const d=ctx.getImageData(cx,cy,1,1).data; bootOK=(d[0]+d[1]+d[2])>0; }

  // ==== Loop ====
  let prev=performance.now();
  function frame(now){
    dtGlobal=Math.min(0.033,(now-prev)/1000); prev=now;
    if(!bootChecked){ bootChecked=true; bootTest(); centerMe(); }
    move(dtGlobal);

    // firing
    const firing=(P.fireHeld||P.latched)&&(P.drain?P.bat>0:true);
    P.cd-=dtGlobal; if(firing&&P.cd<=0){ fireSingle(); P.cd=1/P.rate; }
    if(!firing&&P.drain){ P.bat=Math.min(P.batMax, P.bat+P.rech*dtGlobal); }

    // step photons/emits/molecules
    for(let i=photons.length-1;i>=0;i--){ const p=photons[i]; p.step(dtGlobal); const hit=tryBreak(p); if(hit||!p.alive()) photons.splice(i,1); }
    for(const m of mols) m.step(dtGlobal);
    for(let i=emits.length-1;i>=0;i--){ const e=emits[i]; e.step(dtGlobal); if(!e.alive()) emits.splice(i,1); }

    // draw
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);

    // emissions field
    const tint=w2rgb(P.λ); const rgba=(a=1)=>`rgba(${tint.r},${tint.g},${tint.b},${a})`;
    for(let y=0;y<rows;y++){ for(let x=0;x<cols;x++){ let amp=0; const cx=x+0.5, cy=y+0.5;
      for(const e of emits){ if(e.bb(cx,cy)) amp=Math.max(amp, e.sample(cx,cy)); }
      if(amp>0.06){ const i=Math.min(rampLen-1, Math.max(0, Math.floor(amp*(rampLen-1)))); ctx.fillStyle=rgba(Math.min(1,0.18+amp*0.95)); ctx.fillText(ramp[i], x*cellW, y*cellH); } } }

    // molecules
    for(const m of mols) m.draw();

    // aim dots
    if(aimDots){ const dx=Math.cos(P.ang), dy=Math.sin(P.ang); ctx.fillStyle='rgba(255,255,255,0.3)';
      for(let i=1;i<cols*0.8;i+=2){ const nx=Math.round(P.x+dx*i), ny=Math.round(P.y+dy*i); if(nx<1||nx>=cols-1||ny<1||ny>=rows-1) break; ctx.fillText('.', nx*cellW, ny*cellH); } }

    // photons
    for(const p of photons){ ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.fillText('*', Math.round(p.x)*cellW, Math.round(p.y)*cellH); }

    // player marker LAST
    drawPlayer();

    // HUD + errors
    function hud(x,y,s,a){ ctx.fillStyle=a; ctx.fillText(s,x*cellW,y*cellH); }
    const nm=Math.round(P.λ), E=(1240/Math.max(1,nm)).toFixed(2), bar=Math.floor((P.bat/P.batMax)*20);
    hud(1,1,`λ=${nm}nm  E=${E}eV  move: WASD  aim: mouse  fire: space/click  [V] beacon  [C] center`, 'rgba(180,220,255,0.9)');
    hud(1,2,`battery [${'#'.repeat(bar)}${'.'.repeat(20-bar)}] ${Math.max(0,Math.round(P.bat))}/${P.batMax}   mol:${mols.length}  photons:${photons.length}  emits:${emits.length}`, 'rgba(160,200,255,0.85)');
    if(!bootOK) hud(1,3,`BOOT VISIBILITY FAIL: forced rectangles active`, 'rgba(255,120,120,0.95)');
    if(errs.length){ hud(1,4,`ERROR: ${errs[errs.length-1]}`, 'rgba(255,140,140,0.95)'); }

    requestAnimationFrame(frame);
  }
  let debug=false, aimDots=true;
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
