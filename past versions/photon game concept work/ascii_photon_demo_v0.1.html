<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ASCII Photon — Blink + Wavefront Demo</title>
<style>
  html, body { margin:0; padding:0; background:#000; color:#9ad1ff; height:100%; }
  #wrap { display:flex; flex-direction:column; height:100%; }
  #ui { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        font-size:14px; line-height:1.3; padding:8px 10px; color:#bfe3ff; background:#0b1016; border-bottom:1px solid #0f1926; }
  #ui code { color:#ffe08a; }
  #c { flex:1 1 auto; display:block; width:100%; height:100%; background:#000; }
</style>
</head>
<body>
<div id="wrap">
  <div id="ui">
    <strong>ASCII Photon Demo</strong> — click anywhere to <em>blink</em> the photon, watch the wavefront expand.<br>
    Keys: <code>1</code>=700 nm, <code>2</code>=600, <code>3</code>=500, <code>4</code>=400, <code>5</code>=320 nm,
    <code>C</code>=clear fronts, <code>R</code>=reset position.
  </div>
  <canvas id="c"></canvas>
</div>

<script>
(() => {
  // Grid settings
  const cellW = 9;         // px per cell (width)
  const cellH = 16;        // px per cell (height) — tuned for Courier New / monospace
  let cols = 120;          // grid width in cells
  let rows = 48;           // grid height in cells

  // ASCII ramp from dim to bright
  const ramp = " .:-=+*#%@";
  const rampLen = ramp.length;

  // Canvas setup
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
  ctx.imageSmoothingEnabled = false;
  ctx.textBaseline = 'top';
  ctx.font = '14px Courier New, monospace';

  // Resize canvas to fit window while keeping integer cells
  function fitCanvas() {
    const W = window.innerWidth;
    const H = window.innerHeight - document.getElementById('ui').offsetHeight;
    cols = Math.max(60, Math.floor(W / cellW));
    rows = Math.max(24, Math.floor(H / cellH));
    canvas.width = cols * cellW;
    canvas.height = rows * cellH;
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // Photon state
  const PhotonState = {
    lambdaNm: 656.28,   // active wavelength
    pos: { x: Math.floor(cols * 0.2), y: Math.floor(rows * 0.5) },
    speedScale(nm) {
      const LMIN = 200, LMAX = 800;
      const inv = 1 / Math.min(Math.max(nm, LMIN), LMAX);
      const invMin = 1 / LMIN;
      const invMax = 1 / LMAX;
      return 1.0 + 0.7 * ((inv - invMax) / (invMin - invMax)); // ~1.0..1.7
    }
  };

  // Wavefront data structure
  class Wavefront {
    constructor(segments, lambdaNm) {
      this.segments = segments;     // array of {ax, ay, bx, by}
      this.lambdaNm = lambdaNm;
      this.t = 0;
      this.life = 0.9;              // seconds
      this.expand = 10.0;           // cells/sec expansion speed
      this.sigma = 0.6;             // ring thickness
      this.omega = 7.5;             // stripe animation speed
    }
    alive() { return this.t < this.life; }
    step(dt) { this.t += dt; }
    // Signed distance from cell center to nearest segment, and whether projection is on segment
    minDistToSegments(cx, cy) {
      let min = 1e9;
      for (let i = 0; i < this.segments.length; i++) {
        const s = this.segments[i];
        const dx = s.bx - s.ax, dy = s.by - s.ay;
        const len2 = dx*dx + dy*dy + 1e-6;
        const t = Math.max(0, Math.min(1, ((cx - s.ax)*dx + (cy - s.ay)*dy) / len2));
        const px = s.ax + t*dx, py = s.ay + t*dy;
        const ddx = cx - px, ddy = cy - py;
        const d = Math.hypot(ddx, ddy);
        if (d < min) min = d;
      }
      return min;
    }
    sample(cx, cy) {
      // Compute amplitude from ring distance
      const s = PhotonState.speedScale(this.lambdaNm);
      const w = this.expand * s * this.t; // current ring radius
      const d = this.minDistToSegments(cx, cy);
      const g = Math.exp(-((d - w)*(d - w)) / (2 * this.sigma * this.sigma));
      const env = Math.max(0, 1 - (this.t / this.life));
      // Optional gentle stripes modulation
      const stripes = 0.6 + 0.4 * Math.sin((w - d) * 4.2 - this.t * this.omega);
      return g * env * stripes;
    }
  }

  const wavefronts = [];

  // Bresenham line between two grid points
  function bresenham(ax, ay, bx, by) {
    const points = [];
    let x0 = ax|0, y0 = ay|0, x1 = bx|0, y1 = by|0;
    const dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
    const dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
    let err = dx + dy;
    while (true) {
      points.push({x:x0, y:y0});
      if (x0 === x1 && y0 === y1) break;
      const e2 = 2 * err;
      if (e2 >= dy) { err += dy; x0 += sx; }
      if (e2 <= dx) { err += dx; y0 += sy; }
    }
    return points;
  }

  // Build segments from path points, with spacing >1 condensed
  function pointsToSegments(pts) {
    const segs = [];
    for (let i = 0; i < pts.length - 1; i++) {
      const a = pts[i], b = pts[i+1];
      if (a.x === b.x && a.y === b.y) continue;
      segs.push({ ax:a.x+0.5, ay:a.y+0.5, bx:b.x+0.5, by:b.y+0.5 });
    }
    return segs;
  }

  // Click to blink and spawn a wavefront along the path
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const gx = Math.max(0, Math.min(cols-1, Math.floor(mx / cellW)));
    const gy = Math.max(0, Math.min(rows-1, Math.floor(my / cellH)));
    const path = bresenham(PhotonState.pos.x, PhotonState.pos.y, gx, gy);
    const segs = pointsToSegments(path);
    if (segs.length > 0) {
      PhotonState.pos.x = gx;
      PhotonState.pos.y = gy;
      wavefronts.push(new Wavefront(segs, PhotonState.lambdaNm));
    }
  });

  // Key controls for wavelength and utility
  window.addEventListener('keydown', (e) => {
    if (e.key === '1') PhotonState.lambdaNm = 700;
    else if (e.key === '2') PhotonState.lambdaNm = 600;
    else if (e.key === '3') PhotonState.lambdaNm = 500;
    else if (e.key === '4') PhotonState.lambdaNm = 400;
    else if (e.key === '5') PhotonState.lambdaNm = 320;
    else if (e.key.toLowerCase() === 'c') wavefronts.length = 0;
    else if (e.key.toLowerCase() === 'r') {
      PhotonState.pos.x = Math.floor(cols * 0.2);
      PhotonState.pos.y = Math.floor(rows * 0.5);
      wavefronts.length = 0;
    }
  });

  // Map wavelength to RGB tint (simple HSV mapping for legibility)
  function wavelengthToColor(nm) {
    const x = Math.min(1, Math.max(0, (nm - 380) / (700 - 380))); // 0..1 red->violet
    const hue = (1 - x) * 270; // degrees, ~red to ~violet
    const s = 0.65, v = 1.0;
    const c = v * s;
    const h = hue / 60;
    const xcol = c * (1 - Math.abs((h % 2) - 1));
    let r=0,g=0,b=0;
    if (0<=h && h<1){ r=c; g=xcol; b=0; }
    else if (1<=h && h<2){ r=xcol; g=c; b=0; }
    else if (2<=h && h<3){ r=0; g=c; b=xcol; }
    else if (3<=h && h<4){ r=0; g=xcol; b=c; }
    else if (4<=h && h<5){ r=xcol; g=0; b=c; }
    else { r=c; g=0; b=xcol; }
    const m = v - c;
    return { r: Math.round((r+m)*255), g: Math.round((g+m)*255), b: Math.round((b+m)*255) };
  }

  // Main loop
  let prev = performance.now();
  function frame(now) {
    const dt = Math.min(0.033, (now - prev) / 1000);
    prev = now;

    // Step wavefronts
    for (let i = wavefronts.length - 1; i >= 0; i--) {
      const wf = wavefronts[i];
      wf.step(dt);
      if (!wf.alive()) wavefronts.splice(i, 1);
    }

    // Clear background
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Tint color from wavelength
    const tint = wavelengthToColor(PhotonState.lambdaNm);

    // Draw ASCII grid
    // For performance: build a single string per row and draw via fillText per cell
    // Simpler (and fine at this scale): draw per cell
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        // Photon character
        if (x === PhotonState.pos.x && y === PhotonState.pos.y) {
          ctx.fillStyle = `rgb(${tint.r},${tint.g},${tint.b})`;
          ctx.fillText('@', x*cellW, y*cellH);
          continue;
        }
        // Accumulate amplitude from all wavefronts
        let amp = 0;
        if (wavefronts.length) {
          // Sample center of the cell
          const cx = x + 0.5, cy = y + 0.5;
          for (let i = 0; i < wavefronts.length; i++) {
            amp = Math.max(amp, wavefronts[i].sample(cx, cy));
          }
        }
        if (amp > 0.08) {
          const idx = Math.min(rampLen - 1, Math.max(0, Math.floor(amp * (rampLen - 1))));
          const ch = ramp[idx];
          const a = Math.min(1, 0.25 + amp * 0.9);
          ctx.fillStyle = `rgba(${tint.r},${tint.g},${tint.b},${a})`;
          ctx.fillText(ch, x*cellW, y*cellH);
        }
      }
    }

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
